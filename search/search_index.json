{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"ZIO-ULID","text":"<p>A Scala (and ZIO) implementation of ULID specification</p>"},{"location":"#what-is-ulid","title":"What is ULID?","text":"<p>ULID stands for \"Universally Unique Lexicographically Sortable Identifier\". Read more on Official specification or ZIO-ULID documentation</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>libraryDependencies += \"com.bilal-fazlani\" %% \"zio-ulid\" % \"&lt;VERSION&gt;\"\n</code></pre>"},{"location":"#why-zio-ulid","title":"Why ZIO-ULID?","text":"<p>There are already a few implementations of ULID in Scala, I could not find one that fits natively in ZIO ecosystem. This library takes the core logic from airframe-ulid and implements similar features using ZIO constructs.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Pure. No exceptions or any other side effects</li> <li>Uses ZIO <code>Clock</code> for timestamps</li> <li>Uses ZIO <code>Random</code> for randomness</li> <li>Uses ZIO <code>Ref</code> for thread safety of state</li> <li>Uses <code>ZLayer</code> for dependency injection</li> <li>Returns <code>ZIO[ULIDGen, Nothing, ULID]</code></li> </ul>  <p> Documentation  Github</p>"},{"location":"#inspirations","title":"Inspirations","text":"<ul> <li>https://wvlet.org/airframe/docs/airframe-ulid (core logic)</li> <li>https://github.com/petitviolet/ulid4s</li> </ul>"},{"location":"#tools-and-references-used","title":"Tools and references used","text":"<ul> <li>http://www.crockford.com/base32.html</li> <li>https://ulidgenerator.com/</li> <li>https://www.ulidtools.com/</li> <li>https://cryptii.com/pipes/crockford-base32</li> <li>https://currentmillis.com/</li> <li>https://stackoverflow.com/a/10813256/1365053</li> </ul>"},{"location":"progress/","title":"Progress","text":"<ul> <li> cross compile for Scala 2.13 and 3</li> <li> cross compile for ScalaJS</li> <li> performance benchmarks</li> <li> <code>TestULID</code> implementation for testing with custom time and randomness seeds</li> <li> github actions to test</li> <li> github actions to publish</li> <li> code coverage</li> <li> documentation with examples<ul> <li> error handling</li> <li> creating JSON codec examples</li> </ul> </li> <li> separate errors for string and bytes decoding</li> <li> [bug fix] i, o and l encoding should be supported</li> </ul>"},{"location":"documentation/","title":"Getting started","text":""},{"location":"documentation/#generating-new-ulids","title":"Generating new ULIDs","text":"<p>Here is an example of generating a ULID. Generating ULIDs require a <code>ULIDGen</code> which is a <code>ZLayer</code>. You can create a <code>ULIDGen</code> using <code>ULIDGen.live</code>.</p> <pre><code>import com.bilalfazlani.zioUlid.*\n\nval program = for\n  // make a new ULID\n  ulid &lt;- ULID.nextULID\n\n  // .toString gives a string representation of the ULID\n  _ &lt;- Console.printLine(ulid.toString)\nyield ()\n\nval run = program.provide(ULIDGen.live)\n</code></pre> <p><code>.toString</code> gives us the string representation of ULID</p>  <p>Warning</p> <p>If system datetime is set to more than August 10,889, then fiber will die with <code>UnsupportedSystemDateTime</code> exception</p>   <p>Important</p> <p>Since <code>ULIDGen</code> is a stateful layer, you should have only one instance of <code>ULIDGen</code> in your application. You can ensure that by using <code>ULIDGen.live</code> only once in your application, ideally at at the start/root of your application.</p>"},{"location":"documentation/#timestamp","title":"Timestamp","text":"<p>To know when a ULID was generated, we can get the timestamp from a ULID. Its a <code>Long</code> value representing Unix epoch milliseconds. </p> <pre><code>// get the timestamp of a ULID\nval timestampMillis: Long = ulid.timestamp\n\n// convert the millis to a isntant or datetime\nval datetime = ZonedDateTime.ofInstant(\n  Instant.ofEpochMilli(timestampMillis),\n  ZoneId.of(\"Z\")\n)\n</code></pre>"},{"location":"documentation/#comparing-and-sorting-ulids","title":"Comparing and sorting ULIDs","text":"<p>Since ULIDs are lexicographically sortable, we can compare them with each other and sort them.</p> <pre><code>import com.bilalfazlani.zioUlid.ULID\n\nval program =\n  for\n    // make new ULIDs\n    ulid1 &lt;- ULID.nextULID\n    ulid2 &lt;- ULID.nextULID\n\n    // compare two ULIDs\n    equals = ulid1 == ulid2\n    lessThan = ulid1 &lt; ulid2\n    greaterThan = ulid1 &gt; ulid2\n\n    // sort ULIDs\n    sortedUlids = List(ulid2, ulid1).sorted\n  yield ()\n</code></pre>"},{"location":"documentation/#binary-encoding","title":"Binary encoding","text":"<p>There are two binary representations of ULIDs. One is a <code>Chunk[Byte]</code> of size 16 and the other a tuple (pair) of two 64 bit <code>Long</code> values.</p> <pre><code>import com.bilalfazlani.zioUlid.ULID\n\nval program = for\n  // make a new ULID\n  ulid: ULID &lt;- ULID.nextULID\n\n  // get a bytes representation of a ULID\n  bytes: Chunk[Byte] = ulid.bytes\n\n  // get a tuple (high, low) representation of a ULID\n  tuple: (Long, Long) = ulid.tuple\nyield ()\n</code></pre>"},{"location":"documentation/#converting-a-tuplelong-long-to-ulid","title":"Converting a <code>Tuple[Long, Long]</code> to ULID","text":"<p>You can easily convert a tuple of two <code>Long</code>s into a ULID</p> <pre><code>// decode a ULID from a tuple\nval ulid: ULID = ULID(123412312L, 2134234423L)\n</code></pre> <p>This is a direct operation and does not need any validations as any two Longs are a valid ULID</p>"},{"location":"documentation/#parsing-a-string","title":"Parsing a String","text":"<p>Parsing a string into a ULID returns <code>Either[ULIDStringParsingError, ULID]</code>. It can fail with following errors</p> <ul> <li><code>ULIDStringParsingError.InvalidLength</code> when string length is not 26</li> <li><code>ULIDStringParsingError.InvalidCharacters</code> when string contains characters which are not supported by encoding</li> <li><code>ULIDStringParsingError.OverflowValue</code> when string contains a value which is greater than 128 bits</li> </ul> <pre><code>import com.bilalfazlani.zioUlid.{ULID, ULIDStringParsingError}\nimport ULIDStringParsingError.*\n\nprivate def getInputString: String = ???\n\n// decode a ULID from a string\nval ulid: Either[ULIDStringParsingError, ULID] = ULID(getInputString)\n\nulid.fold(\n  {\n    case InvalidCharacters(_) =&gt;\n      println(\"Invalid characters in the string\")\n    case InvalidLength(_) =&gt;\n      println(s\"Invalid length of string\")\n    case OverflowValue(string) =&gt;\n      println(s\"Overflow value $string\")\n  },\n  ulid =&gt; println(ulid.toString)\n)\n</code></pre> <p>It is also possible to validate a string using pattern matching</p> <pre><code>// validate a string as a ULID using pattern matching\ngetInputString match {\n  case ULID(string)  =&gt; println(s\"Valid ULID: $string\")\n  case invalidString =&gt; println(s\"Invalid ULID: $invalidString\")\n}\n</code></pre>"},{"location":"documentation/#parsing-chunk-of-bytes","title":"Parsing chunk of bytes","text":"<p>When parsing bytes into a ULID, validation of chunk size is performed. If size is not 16, then <code>Left[ULIDBytesParsingError.InvalidBytesLength]</code> is returned.</p> <pre><code>import com.bilalfazlani.zioUlid.*\n\nprivate def getInputBytes: Chunk[Byte] = ???\n\n// decode a ULID from bytes\nval ulid: Either[ULIDBytesParsingError.InvalidBytesLength, ULID] = ULID(\n  getInputBytes\n)\n</code></pre> <p>Similar to validation of Strings, its also possible to validate bytes using pattern matching</p> <pre><code>// validate bytes as a ULID using pattern matching\ngetInputBytes match {\n  case validBytes @ ULID(string) =&gt; println(\"Valid ULID: \" + string)\n  case invalidBytes              =&gt; println(\"bytes are invalid\")\n}\n</code></pre>"},{"location":"documentation/#parsing-chunkbyte-with-separate-timestamp","title":"Parsing <code>Chunk[Byte]</code> with separate timestamp","text":"<p>You can create a ULID from a timestamp (<code>Long</code>) and a <code>Chunk[Byte]</code>. Chunk should be of size 10. Timestamp should be &lt;= 48 bits.</p> <pre><code>import com.bilalfazlani.zioUlid.*\n\n// create a ULID from a timestamp and bytes\nval ulid: Either[ULIDBytesParsingError, ULID] =\n  ULID(getTimestamp, getRandomBytes)\n</code></pre> <p>This will return an <code>Either[ULIDBytesParsingError, ULID]</code> with following errors</p> <ul> <li><code>ULIDBytesParsingError.InvalidBytesLength</code> when chunk size is not 10</li> <li><code>ULIDBytesParsingError.InvalidTimestamp</code> when timestamp is greater than 48 bits</li> </ul>"},{"location":"documentation/generation/","title":"ULID Generation","text":"<p>Everytime you call <code>nextULID</code>, a new ULID is generated. It get's current millisecond time using ZIO's <code>Clock</code> and 10 random bytes using ZIO's <code>Random</code>. It then encodes the time and random bytes into a ULID. However, this simple implementation can cause random collision if you generate ULIDs in the same millisecond. </p>"},{"location":"documentation/generation/#how-is-random-collision-avoided","title":"How is random collision avoided?","text":"<p>To avoid it, <code>ULIDGen</code> is a stateful layer. It stores the last millisecond when ULID was generated and the last random bytes used. When <code>nextULID</code> is called, it compares current milliseconds with last milliseconds and if they are same, it does not generate new random bytes. Instead, it increments the last random bytes by 1, combines it with current milliseconds and encodes it into a ULID. It also stores the current milliseconds and random bytes in the state. To access and modify this state in a threadsafe manner, it uses ZIO's <code>Ref</code>.</p> <p>This behaviour is called monotonical increase. And because of this behaviour, ULIDs generated by <code>ULIDGen</code> are lexicographically sortable.</p>"},{"location":"documentation/generation/#how-is-overflow-avoided","title":"How is overflow avoided?","text":"<p>Maximum value of random bytes, as per spec encoding is <code>ZZZZZZZZZZZZZZZZ</code>. What if we have a huge compute power and we are able to generate lots of (more than 2^80 - 1) ULIDs in the same millisecond? In that case, we will run out of random bytes.</p> <p>ZIO-ULID does not return error in such case. Instead, within same millisecond <code>ULIDGen</code> checks if the last generated random bytes is <code>ZZZZZZZZZZZZZZZZ</code>. If it is, it waits for 1 millisecond and then generates a new ULID.</p>  <p>Note</p> <p>Monotonical increase to avoid random collision and waiting for 1 millisecond to avoid overflow both are scoped to a millisecond. ULIDs generated in different milliseconds are not affected by these behaviours.</p>   <p>Note2</p> <p>Both these concepts are taken from airframe-ulid implementation. Implementation is different since ZIO-ULID is implemented in ZIO.</p>"},{"location":"documentation/structure-encoding/","title":"Structure and Encoding","text":"<p>ULID is a 128 bit number represented as a 26 character string. It is a combination of a timestamp and a random part.</p>"},{"location":"documentation/structure-encoding/#binary-structure","title":"Binary Structure","text":"<p>   </p> <p>The 48 bits form an Integer value and it's a reprensentation of the timestamp in milliseconds. The maximum value it can hold is 281474976710655 (2^48 - 1). That year 10,889 AD.</p> <p>80 bits are for the random component.</p>"},{"location":"documentation/structure-encoding/#encoding","title":"Encoding","text":"<p>These 128 bits are represented as string using a 5 bit encoding to form 26 characters. This encoding is called Crockford's Base32.</p>  <p>There are no special characters in the encoding. The encoding is case insensitive. Decoding of lower case letters is supported. At the time or encoding, all characters and ecoded as upper case. To avoid mistakes, characters <code>i</code>, <code>l</code>, <code>o</code> and <code>u</code> are not used while encoding.</p> <p>While decoding, <code>o</code> and <code>O</code> are treated as <code>0</code>. Characters <code>i</code>, <code>I</code>, <code>l</code> and <code>L</code> are treated as <code>1</code>. <code>u</code> / <code>U</code> is considered invalid.</p>    Char Binary Decimal HEX     <code>0</code>, <code>o/O</code> <code>00000</code> <code>0</code> <code>0</code>   <code>1</code>, <code>i/I</code>, <code>l/L</code> <code>00001</code> <code>1</code> <code>1</code>   <code>2</code> <code>00010</code> <code>2</code> <code>2</code>   <code>3</code> <code>00011</code> <code>3</code> <code>3</code>   <code>4</code> <code>00100</code> <code>4</code> <code>4</code>   <code>5</code> <code>00101</code> <code>5</code> <code>5</code>   <code>6</code> <code>00110</code> <code>6</code> <code>6</code>   <code>7</code> <code>00111</code> <code>7</code> <code>7</code>   <code>8</code> <code>01000</code> <code>8</code> <code>8</code>   <code>9</code> <code>01001</code> <code>9</code> <code>9</code>   <code>a/A</code> <code>01010</code> <code>10</code> <code>A</code>   <code>b/B</code> <code>01011</code> <code>11</code> <code>B</code>   <code>c/C</code> <code>01100</code> <code>12</code> <code>C</code>   <code>d/D</code> <code>01101</code> <code>13</code> <code>D</code>   <code>e/E</code> <code>01110</code> <code>14</code> <code>E</code>   <code>f/F</code> <code>01111</code> <code>15</code> <code>F</code>   <code>g/G</code> <code>10000</code> <code>16</code> <code>10</code>   <code>h/H</code> <code>10001</code> <code>17</code> <code>11</code>   <code>j/J</code> <code>10010</code> <code>18</code> <code>12</code>   <code>k/K</code> <code>10011</code> <code>19</code> <code>13</code>   <code>m/M</code> <code>10100</code> <code>20</code> <code>14</code>   <code>n/N</code> <code>10101</code> <code>21</code> <code>15</code>   <code>p/P</code> <code>10110</code> <code>22</code> <code>16</code>   <code>q/Q</code> <code>10111</code> <code>23</code> <code>17</code>   <code>r/R</code> <code>11000</code> <code>24</code> <code>18</code>   <code>s/S</code> <code>11001</code> <code>25</code> <code>19</code>   <code>t/T</code> <code>11010</code> <code>26</code> <code>1A</code>   <code>v/V</code> <code>11011</code> <code>27</code> <code>1B</code>   <code>w/W</code> <code>11100</code> <code>28</code> <code>1C</code>   <code>x/X</code> <code>11101</code> <code>29</code> <code>1D</code>   <code>y/Y</code> <code>11110</code> <code>30</code> <code>1E</code>   <code>z/Z</code> <code>11111</code> <code>31</code> <code>1F</code>"}]}